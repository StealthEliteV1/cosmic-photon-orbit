<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3d black hole photon simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>3D Black Hole Photon Simulation</h2>
        <p>use the controls to customize the simulation.</p>
    </div>
    <script>
        let scene, camera, renderer, blackHole, photons, stars;
        const params = {
            photonCount: 3000,
            blackHoleRadius: 5,
            orbitRadius: 15,
            starCount: 10000,
            cameraDistance: 100,
            cameraSpeed: 0.0005,
            gravitationalStrength: 100,
            fallingPhotonColor: '#ff0000',
            orbitingPhotonColor: '#ffff00',
            escapingPhotonColor: '#0000ff',
            starColor: '#ffffff',
            showBlackHole: true
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = params.cameraDistance;

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createBlackHole();
            createPhotons();
            createStars();
            setupGUI();

            animate();
        }

        function createBlackHole() {
            const blackHoleGeometry = new THREE.SphereGeometry(params.blackHoleRadius, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            scene.add(blackHole);
        }

        function createPhotons() {
            if (photons) scene.remove(photons);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.photonCount * 3);
            const colors = new Float32Array(params.photonCount * 3);
            const velocities = new Float32Array(params.photonCount * 3);

            for (let i = 0; i < params.photonCount; i++) {
                resetPhoton(i, positions, velocities, colors);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            photons = new THREE.Points(geometry, material);
            photons.userData.velocities = velocities;
            scene.add(photons);
        }

        function createStars() {
            if (stars) scene.remove(stars);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.starCount * 3);

            for (let i = 0; i < params.starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: params.starColor,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });

            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        function resetPhoton(index, positions, velocities, colors) {
            const i3 = index * 3;
            let r, theta, phi, vx, vy, vz;

            r = params.orbitRadius * (0.8 + Math.random() * 0.4);
            theta = Math.random() * Math.PI * 2;
            phi = Math.acos(2 * Math.random() - 1);

            if (index < params.photonCount / 3) {
                // Falling photons
                setColor(colors, i3, params.fallingPhotonColor);
                vx = vy = vz = 0; // Initial velocity towards black hole
            } else if (index < 2 * params.photonCount / 3) {
                // Orbiting photons
                setColor(colors, i3, params.orbitingPhotonColor);
                // Tangential velocity for circular orbit
                const v = Math.sqrt(1 / Math.max(r, 0.1)) * 0.7;
                vx = -v * Math.sin(theta);
                vy = v * Math.cos(theta);
                vz = 0;
            } else {
                // Escaping photons
                setColor(colors, i3, params.escapingPhotonColor);
                // Velocity with both radial and tangential components
                const v = Math.sqrt(2 / Math.max(r, 0.1)) * 0.5;
                vx = v * Math.cos(theta);
                vy = v * Math.sin(theta);
                vz = v * Math.cos(phi);
            }

            positions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = r * Math.cos(phi);

            velocities[i3] = vx;
            velocities[i3 + 1] = vy;
            velocities[i3 + 2] = vz;
        }

        function setColor(colors, index, hexColor) {
            const color = new THREE.Color(hexColor);
            colors[index] = color.r;
            colors[index + 1] = color.g;
            colors[index + 2] = color.b;
        }

        function updateColors() {
            const colors = photons.geometry.attributes.color.array;
            for (let i = 0; i < params.photonCount; i++) {
                const i3 = i * 3;
                if (i < params.photonCount / 3) {
                    setColor(colors, i3, params.fallingPhotonColor);
                } else if (i < 2 * params.photonCount / 3) {
                    setColor(colors, i3, params.orbitingPhotonColor);
                } else {
                    setColor(colors, i3, params.escapingPhotonColor);
                }
            }
            photons.geometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const positions = photons.geometry.attributes.position.array;
            const velocities = photons.userData.velocities;

            for (let i = 0; i < params.photonCount; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];

                const distanceSq = x*x + y*y + z*z;
                const distance = Math.sqrt(distanceSq);

                if (isNaN(distance) || distance < params.blackHoleRadius || distance > params.orbitRadius * 3) {
                    resetPhoton(i, positions, velocities, photons.geometry.attributes.color.array);
                    continue;
                }

                // Update velocity (simplified gravity)
                const force = params.gravitationalStrength / Math.max(distanceSq, 0.1);
                velocities[i3] -= force * x / distance * 0.016;
                velocities[i3 + 1] -= force * y / distance * 0.016;
                velocities[i3 + 2] -= force * z / distance * 0.016;

                // Update position
                positions[i3] += velocities[i3];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];
            }

            photons.geometry.attributes.position.needsUpdate = true;

            // Rotate camera
            const time = Date.now() * params.cameraSpeed;
            camera.position.x = Math.cos(time) * params.cameraDistance;
            camera.position.z = Math.sin(time) * params.cameraDistance;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        function setupGUI() {
            const gui = new dat.GUI();
            gui.add(params, 'photonCount', 1000, 10000).step(100).onChange(createPhotons);
            gui.add(params, 'blackHoleRadius', 1, 20).onChange(value => {
                blackHole.scale.setScalar(value / 5);
            });
            gui.add(params, 'orbitRadius', 10, 50).onChange(createPhotons);
            gui.add(params, 'cameraDistance', 50, 200);
            gui.add(params, 'cameraSpeed', 0, 0.002);
            gui.add(params, 'gravitationalStrength', 10, 500);
            gui.addColor(params, 'fallingPhotonColor').onChange(updateColors);
            gui.addColor(params, 'orbitingPhotonColor').onChange(updateColors);
            gui.addColor(params, 'escapingPhotonColor').onChange(updateColors);
            gui.addColor(params, 'starColor').onChange(value => {
                stars.material.color.setHex(parseInt(value.replace('#', '0x')));
            });
            gui.add(params, 'showBlackHole').onChange(value => {
                blackHole.visible = value;
            });
        }

        init();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
