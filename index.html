<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Gravitational Lensing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute float size;
    varying vec3 vColor;
    uniform float time;
    uniform float blackHoleStrength;
    uniform vec2 blackHolePosition;

    void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

        // Calculate distance to black hole
        vec2 toBlackHole = blackHolePosition - mvPosition.xy;
        float dist = length(toBlackHole);

        // Apply gravitational lensing effect
        float strength = blackHoleStrength / (dist * dist + 0.1);
        mvPosition.xy += normalize(toBlackHole) * strength;

        gl_PointSize = size * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    varying vec3 vColor;
    void main() {
        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
        gl_FragColor = vec4(vColor, 1.0);
    }
</script>
<script>
    let scene, camera, renderer, particles, blackHoleMesh;
    let gui, params;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        params = {
            starCount: 10000,
            blackHoleStrength: 20,
            blackHoleX: 0,
            blackHoleY: 0
        };

        createStars();
        createBlackHoleIndicator();
        setupGUI();
        animate();
    }

    function createStars() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        for (let i = 0; i < params.starCount; i++) {
            positions.push((Math.random() - 0.5) * 100);
            positions.push((Math.random() - 0.5) * 100);
            positions.push((Math.random() - 0.5) * 100);

            colors.push(Math.random() * 0.5 + 0.5);
            colors.push(Math.random() * 0.5 + 0.5);
            colors.push(Math.random() * 0.5 + 0.5);

            sizes.push(Math.random() * 2 + 1);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                blackHoleStrength: { value: params.blackHoleStrength },
                blackHolePosition: { value: new THREE.Vector2(params.blackHoleX, params.blackHoleY) }
            },
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            transparent: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    function createBlackHoleIndicator() {
        const geometry = new THREE.CircleGeometry(1, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
        blackHoleMesh = new THREE.Mesh(geometry, material);
        scene.add(blackHoleMesh);
    }

    function setupGUI() {
        gui = new dat.GUI();
        gui.add(params, 'blackHoleStrength', 0, 100).onChange(updateUniforms);
        gui.add(params, 'blackHoleX', -50, 50).onChange(updateUniforms);
        gui.add(params, 'blackHoleY', -50, 50).onChange(updateUniforms);
    }

    function updateUniforms() {
        particles.material.uniforms.blackHoleStrength.value = params.blackHoleStrength;
        particles.material.uniforms.blackHolePosition.value.set(params.blackHoleX, params.blackHoleY);
        blackHoleMesh.position.set(params.blackHoleX, params.blackHoleY, 0);
    }

    function animate() {
        requestAnimationFrame(animate);
        particles.material.uniforms.time.value += 0.01;
        renderer.render(scene, camera);
    }

    init();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>